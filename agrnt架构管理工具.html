<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LangGraph Agent å·¥ä½œæµè®¾è®¡å™¨</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f6fa;
            overflow: hidden;
            height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }
        
        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .header {
            height: 50px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        .breadcrumb-item {
            cursor: pointer;
            padding: 4px 12px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .breadcrumb-item:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .breadcrumb-item.active {
            font-weight: bold;
            color: #3498db;
        }
        
        .breadcrumb-separator {
            color: #7f8c8d;
        }
        
        /* ä¸»ä½“å¸ƒå±€ */
        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        /* å·¦ä¾§å·¥å…·æ  */
        .toolbar {
            width: 260px;
            background: white;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tool-section h3 {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }
        
        .tool-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: 2px solid transparent;
            background: #ecf0f1;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            font-size: 13px;
        }
        
        .tool-btn:hover {
            background: #e0e6ed;
            transform: translateX(3px);
        }
        
        .tool-btn.active {
            border-color: #3498db;
            background: #ebf5fb;
        }
        
        .tool-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .action-btn {
            background: #27ae60;
            color: white;
            border: none;
        }
        
        .action-btn:hover { background: #229954; }
        
        .danger-btn {
            background: #e74c3c;
            color: white;
            border: none;
        }
        
        .danger-btn:hover { background: #c0392b; }
        
        /* ç”»å¸ƒåŒºåŸŸ */
        .canvas-wrapper {
            flex: 1;
            position: relative;
            background: #f8f9fa;
            overflow: hidden;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .canvas-hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }
        
        .canvas-hint.show { opacity: 1; }
        
        /* å³ä¾§é¢æ¿ */
        .properties {
            width: 320px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }
        
        .properties h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .prop-group {
            margin-bottom: 20px;
        }
        
        .prop-group label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
            font-weight: 600;
        }
        
        .prop-group input,
        .prop-group select,
        .prop-group textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .prop-group textarea {
            min-height: 80px;
            resize: vertical;
            font-family: monospace;
        }
        
        .prop-group small {
            color: #95a5a6;
            font-size: 11px;
            margin-top: 4px;
            display: block;
        }
        
        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .tag {
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .tag button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
        }
        
        /* æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal.show { display: flex; }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-body {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .tab {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 20px;
            overflow-x: auto;
            margin: 10px 0;
        }
        
        .code-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .download-btn {
            background: #2980b9;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 13px;
        }
        
        .download-btn:hover { background: #3498db; }
        
        /* å­å›¾å…¥å£æç¤º */
        .subgraph-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(155, 89, 182, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 13px;
            display: none;
        }
        
        .subgraph-hint.show { display: block; }
        
        /* å¸®åŠ©é¢æ¿ */
        .help-panel {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.6;
            color: #555;
        }
        
        .help-panel h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .node-legend {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }
        
        .legend-shape {
            width: 20px;
            height: 20px;
            border: 2px solid;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- é¡¶éƒ¨å¯¼èˆª -->
        <div class="header">
            <div class="breadcrumb" id="breadcrumb">
                <span class="breadcrumb-item active" onclick="navigateToRoot()">ä¸»å·¥ä½œæµ</span>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="download-btn" onclick="generateCode()">ç”Ÿæˆä»£ç </button>
                <button class="download-btn" onclick="exportGraph()" style="background: #8e44ad;">å¯¼å‡º</button>
                <input type="file" id="import-file" style="display: none;" onchange="importGraph(event)">
                <button class="download-btn" onclick="document.getElementById('import-file').click()" style="background: #16a085;">å¯¼å…¥</button>
            </div>
        </div>
        
        <!-- ä¸»ä½“ -->
        <div class="main">
            <!-- å·¦ä¾§å·¥å…·æ  -->
            <div class="toolbar">
                <div class="tool-section">
                    <h3>åŸºç¡€èŠ‚ç‚¹</h3>
                    <button class="tool-btn" onclick="setTool('start')" id="btn-start">
                        <span class="tool-icon" style="background: #d5f4e6; color: #27ae60;">â—</span>
                        å¼€å§‹ (Start)
                    </button>
                    <button class="tool-btn" onclick="setTool('end')" id="btn-end">
                        <span class="tool-icon" style="background: #fadbd8; color: #e74c3c;">â—</span>
                        ç»“æŸ (End)
                    </button>
                    <button class="tool-btn" onclick="setTool('process')" id="btn-process">
                        <span class="tool-icon" style="background: #d6eaf8; color: #3498db;">â–­</span>
                        å¤„ç† (Process)
                    </button>
                    <button class="tool-btn" onclick="setTool('conditional')" id="btn-conditional">
                        <span class="tool-icon" style="background: #fdebd0; color: #f39c12;">â—†</span>
                        æ¡ä»¶ (Condition)
                    </button>
                </div>
                
                <div class="tool-section">
                    <h3>Agent ä¸“ç”¨</h3>
                    <button class="tool-btn" onclick="setTool('agent')" id="btn-agent">
                        <span class="tool-icon" style="background: #e8daef; color: #9b59b6;">ğŸ¤–</span>
                        Agent å¾ªç¯
                    </button>
                    <button class="tool-btn" onclick="setTool('tool')" id="btn-tool">
                        <span class="tool-icon" style="background: #f5cba7; color: #e67e22;">ğŸ”§</span>
                        å·¥å…·è°ƒç”¨
                    </button>
                    <button class="tool-btn" onclick="setTool('human')" id="btn-human">
                        <span class="tool-icon" style="background: #d1f2eb; color: #1abc9c;">ğŸ‘¤</span>
                        äººå·¥ä¸­æ–­
                    </button>
                    <button class="tool-btn" onclick="setTool('parallel')" id="btn-parallel">
                        <span class="tool-icon" style="background: #d5d8dc; color: #34495e;">âš¡</span>
                        å¹¶è¡Œç½‘å…³
                    </button>
                </div>
                
                <div class="tool-section">
                    <h3>å·¥å…·</h3>
                    <button class="tool-btn" onclick="setTool('edge')" id="btn-edge">
                        <span class="tool-icon" style="background: #eaeded; color: #555;">â†’</span>
                        è¿æ¥è¾¹
                    </button>
                    <button class="tool-btn danger-btn" onclick="clearCanvas()">
                        <span class="tool-icon" style="background: rgba(255,255,255,0.2);">ğŸ—‘</span>
                        æ¸…ç©ºç”»å¸ƒ
                    </button>
                </div>
                
                <div class="help-panel">
                    <h4>ğŸ’¡ æ“ä½œæç¤º</h4>
                    <div style="margin-bottom: 8px;">â€¢ <strong>åŒå‡» Agent èŠ‚ç‚¹</strong>è¿›å…¥å­å›¾ç¼–è¾‘</div>
                    <div style="margin-bottom: 8px;">â€¢ <strong>æ‹–æ‹½</strong>ç§»åŠ¨èŠ‚ç‚¹</div>
                    <div style="margin-bottom: 8px;">â€¢ <strong>Delete</strong>åˆ é™¤é€‰ä¸­é¡¹</div>
                    <div>â€¢ å³é”®ç‚¹å‡»è¾¹å¯åˆ é™¤</div>
                </div>
            </div>
            
            <!-- ç”»å¸ƒ -->
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
                <div class="canvas-hint" id="hint">ç‚¹å‡»æ·»åŠ èŠ‚ç‚¹</div>
                <div class="subgraph-hint" id="subgraph-hint">
                    å½“å‰åœ¨ Agent å­å›¾ä¸­ Â· ç‚¹å‡»é¢åŒ…å±‘è¿”å›ä¸Šçº§
                </div>
            </div>
            
            <!-- å³ä¾§é¢æ¿ -->
            <div class="properties">
                <h3>âš™ï¸ èŠ‚ç‚¹å±æ€§</h3>
                <div id="prop-content">
                    <p style="color: #999; font-style: italic;">è¯·é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œç¼–è¾‘</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- ä»£ç ç”Ÿæˆæ¨¡æ€æ¡† -->
    <div class="modal" id="code-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ğŸ¯ ç”Ÿæˆç»“æœ</h2>
                <button class="download-btn" onclick="closeModal()" style="background: #7f8c8d;">å…³é—­</button>
            </div>
            <div class="modal-body">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('python')">Python ä»£ç </button>
                    <button class="tab" onclick="switchTab('skills')">Skill æ¨¡æ¿</button>
                    <button class="tab" onclick="switchTab('graph')">å›¾æ•°æ®</button>
                </div>
                
                <div id="tab-python" class="tab-content active">
                    <div class="code-block">
                        <pre id="python-code"></pre>
                    </div>
                    <button class="download-btn" onclick="downloadFile('workflow.py', 'python')">ä¸‹è½½ workflow.py</button>
                    <button class="download-btn" onclick="copyToClipboard('python')">å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
                </div>
                
                <div id="tab-skills" class="tab-content">
                    <div id="skills-content"></div>
                </div>
                
                <div id="tab-graph" class="tab-content">
                    <div class="code-block">
                        <pre id="graph-json"></pre>
                    </div>
                    <button class="download-btn" onclick="downloadFile('workflow.json', 'json')">ä¸‹è½½ JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== å…¨å±€çŠ¶æ€ç®¡ç† ====================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // å·¥ä½œæµå›¾æ•°æ®ï¼ˆæ”¯æŒåµŒå¥—ï¼‰
        let workflowData = {
            root: {
                nodes: [],
                edges: [],
                idCounter: 0
            }
        };
        
        // å½“å‰ä¸Šä¸‹æ–‡
        let currentPath = ['root']; // é¢åŒ…å±‘è·¯å¾„
        let currentGraph = workflowData.root; // å½“å‰ç¼–è¾‘çš„å›¾
        
        // äº¤äº’çŠ¶æ€
        let selectedTool = null;
        let selectedNode = null;
        let selectedEdge = null;
        let isDragging = false;
        let dragOffset = {x: 0, y: 0};
        let edgeStart = null;
        let lastMousePos = {x: 0, y: 0};
        
        // èŠ‚ç‚¹ç±»å‹å®šä¹‰
        const NODE_TYPES = {
            start: { color: '#27ae60', label: 'Start', shape: 'circle' },
            end: { color: '#e74c3c', label: 'End', shape: 'circle' },
            process: { color: '#3498db', label: 'Process', shape: 'rect' },
            conditional: { color: '#f39c12', label: 'Condition', shape: 'diamond' },
            agent: { color: '#9b59b6', label: 'Agent', shape: 'double-rect', hasSubgraph: true },
            tool: { color: '#e67e22', label: 'Tool', shape: 'cylinder' },
            human: { color: '#1abc9c', label: 'Human', shape: 'octagon' },
            parallel: { color: '#34495e', label: 'Parallel', shape: 'plus' }
        };
        
        // ==================== ç±»å®šä¹‰ ====================
        
        class Node {
            constructor(x, y, type, name, parentId = null) {
                this.id = `node_${currentGraph.idCounter++}`;
                this.x = x;
                this.y = y;
                this.type = type;
                this.name = name || this.getDefaultName(type);
                this.config = this.getDefaultConfig(type);
                this.parentId = parentId; // çˆ¶AgentèŠ‚ç‚¹IDï¼ˆå¦‚æœåœ¨å­å›¾ä¸­ï¼‰
                
                // å­å›¾ï¼ˆä»…Agentç±»å‹æœ‰ï¼‰
                if (NODE_TYPES[type].hasSubgraph) {
                    this.subgraph = {
                        nodes: [],
                        edges: [],
                        idCounter: 0
                    };
                }
            }
            
            getDefaultName(type) {
                const map = {
                    'start': 'START',
                    'end': 'END',
                    'process': `process_${currentGraph.idCounter}`,
                    'conditional': `decision_${currentGraph.idCounter}`,
                    'agent': `agent_${currentGraph.idCounter}`,
                    'tool': `tool_${currentGraph.idCounter}`,
                    'human': `human_${currentGraph.idCounter}`,
                    'parallel': `parallel_${currentGraph.idCounter}`
                };
                return map[type];
            }
            
            getDefaultConfig(type) {
                const configs = {
                    agent: {
                        model: 'gpt-4',
                        max_iterations: 5,
                        tools: [],
                        system_prompt: ''
                    },
                    tool: {
                        tool_name: '',
                        timeout: 30,
                        retry: 3
                    },
                    human: {
                        timeout: 'infinite',
                        prompt: '',
                        options: []
                    },
                    parallel: {
                        branches: 2,
                        mode: 'all' // 'all' æˆ– 'any'
                    }
                };
                return configs[type] || {};
            }
            
            draw() {
                const typeConfig = NODE_TYPES[this.type];
                ctx.save();
                
                // æ ¹æ®å½¢çŠ¶ç»˜åˆ¶
                switch(typeConfig.shape) {
                    case 'circle':
                        this.drawCircle(typeConfig.color);
                        break;
                    case 'rect':
                        this.drawRect(typeConfig.color);
                        break;
                    case 'diamond':
                        this.drawDiamond(typeConfig.color);
                        break;
                    case 'double-rect':
                        this.drawDoubleRect(typeConfig.color);
                        break;
                    case 'cylinder':
                        this.drawCylinder(typeConfig.color);
                        break;
                    case 'octagon':
                        this.drawOctagon(typeConfig.color);
                        break;
                    case 'plus':
                        this.drawPlus(typeConfig.color);
                        break;
                }
                
                // ç»˜åˆ¶æ–‡å­—
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // æ¢è¡Œå¤„ç†
                if (this.name.length > 12) {
                    const parts = this.name.split('_');
                    if (parts.length > 1) {
                        ctx.fillText(parts[0], this.x, this.y - 7);
                        ctx.fillText(parts.slice(1).join('_'), this.x, this.y + 7);
                    } else {
                        ctx.fillText(this.name.substring(0, 10) + '...', this.x, this.y);
                    }
                } else {
                    ctx.fillText(this.name, this.x, this.y);
                }
                
                // å­å›¾æ ‡è®°ï¼ˆAgentèŠ‚ç‚¹ï¼‰
                if (typeConfig.hasSubgraph && this.subgraph) {
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x + 35, this.y - 25, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.fillText('â†—', this.x + 35, this.y - 25);
                }
                
                // é€‰ä¸­æ ‡è®°
                if (selectedNode === this) {
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            drawCircle(color) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
            }
            
            drawRect(color) {
                this.roundRect(this.x - 50, this.y - 30, 100, 60, 8);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
            }
            
            drawDiamond(color) {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 35);
                ctx.lineTo(this.x + 50, this.y);
                ctx.lineTo(this.x, this.y + 35);
                ctx.lineTo(this.x - 50, this.y);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
            }
            
            drawDoubleRect(color) {
                // å¤–æ¡†
                this.roundRect(this.x - 55, this.y - 35, 110, 70, 10);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
                
                // å†…æ¡†ï¼ˆåŒè¾¹æ•ˆæœï¼‰
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                this.roundRect(this.x - 48, this.y - 28, 96, 56, 6);
                ctx.stroke();
            }
            
            drawCylinder(color) {
                const w = 100, h = 60;
                ctx.fillStyle = color;
                
                // ä¸»ä½“
                ctx.beginPath();
                ctx.moveTo(this.x - w/2, this.y - h/2 + 10);
                ctx.lineTo(this.x - w/2, this.y + h/2 - 10);
                ctx.bezierCurveTo(this.x - w/2, this.y + h/2, this.x + w/2, this.y + h/2, this.x + w/2, this.y + h/2 - 10);
                ctx.lineTo(this.x + w/2, this.y - h/2 + 10);
                ctx.bezierCurveTo(this.x + w/2, this.y - h/2, this.x - w/2, this.y - h/2, this.x - w/2, this.y - h/2 + 10);
                ctx.fill();
                
                // é¡¶é¢
                ctx.beginPath();
                ctx.ellipse(this.x, this.y - h/2 + 10, w/2, 10, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fill();
                
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
            }
            
            drawOctagon(color) {
                const r = 35;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = i * Math.PI / 4 - Math.PI / 8;
                    const x = this.x + r * Math.cos(angle);
                    const y = this.y + r * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.stroke();
            }
            
            drawPlus(color) {
                const size = 40;
                ctx.fillStyle = color;
                
                // æ¨ªæ¡
                ctx.fillRect(this.x - size, this.y - 12, size * 2, 24);
                // ç«–æ¡
                ctx.fillRect(this.x - 12, this.y - size, 24, size * 2);
                
                ctx.strokeStyle = selectedNode === this ? '#2c3e50' : color;
                ctx.lineWidth = selectedNode === this ? 3 : 2;
                ctx.strokeRect(this.x - size, this.y - 12, size * 2, 24);
                ctx.strokeRect(this.x - 12, this.y - size, 24, size * 2);
            }
            
            roundRect(x, y, w, h, r) {
                if (ctx.roundRect) {
                    ctx.beginPath();
                    ctx.roundRect(x, y, w, h, r);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                }
            }
            
            contains(x, y) {
                // ç®€åŒ–ä¸ºçŸ©å½¢æ£€æµ‹
                const hitSize = this.type === 'circle' ? 30 : 
                               this.type === 'diamond' ? 35 : 
                               this.type === 'octagon' ? 35 :
                               this.type === 'plus' ? 40 : 30;
                return x >= this.x - hitSize && x <= this.x + hitSize &&
                       y >= this.y - hitSize && y <= this.y + hitSize;
            }
        }
        
        class Edge {
            constructor(from, to, label = '') {
                this.id = `edge_${Date.now()}_${Math.random()}`;
                this.from = from;
                this.to = to;
                this.label = label;
            }
            
            draw() {
                const start = this.getEdgePoint(this.from, this.to);
                const end = this.getEdgePoint(this.to, this.from);
                
                ctx.save();
                
                // ç»˜åˆ¶çº¿
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰åå‘è¾¹ï¼ˆç»˜åˆ¶æ›²çº¿é¿å…é‡å ï¼‰
                const hasReverse = currentGraph.edges.some(e => 
                    e !== this && e.from === this.to && e.to === this.from
                );
                
                if (hasReverse) {
                    const midX = (start.x + end.x) / 2;
                    const midY = (start.y + end.y) / 2;
                    const angle = Math.atan2(end.y - start.y, end.x - start.x);
                    const perp = angle + Math.PI / 2;
                    ctx.quadraticCurveTo(
                        midX + Math.cos(perp) * 30,
                        midY + Math.sin(perp) * 30,
                        end.x, end.y
                    );
                } else {
                    ctx.lineTo(end.x, end.y);
                }
                
                ctx.strokeStyle = selectedEdge === this ? '#e74c3c' : '#34495e';
                ctx.lineWidth = selectedEdge === this ? 3 : 2;
                ctx.stroke();
                
                // ç®­å¤´
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                const arrowLen = 10;
                ctx.beginPath();
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(
                    end.x - arrowLen * Math.cos(angle - Math.PI/6),
                    end.y - arrowLen * Math.sin(angle - Math.PI/6)
                );
                ctx.moveTo(end.x, end.y);
                ctx.lineTo(
                    end.x - arrowLen * Math.cos(angle + Math.PI/6),
                    end.y - arrowLen * Math.sin(angle + Math.PI/6)
                );
                ctx.stroke();
                
                // æ ‡ç­¾
                if (this.label) {
                    const midX = (start.x + end.x) / 2;
                    const midY = (start.y + end.y) / 2;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(midX - 15, midY - 10, 30, 20);
                    ctx.fillStyle = '#2c3e50';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.label, midX, midY);
                }
                
                ctx.restore();
            }
            
            getEdgePoint(fromNode, toNode) {
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const angle = Math.atan2(dy, dx);
                const r = 30; // ç®€åŒ–ä¸ºç»Ÿä¸€åŠå¾„
                
                if (fromNode.type === 'diamond') {
                    const absAngle = Math.abs(angle);
                    if (absAngle < Math.PI/4) return {x: fromNode.x + 50, y: fromNode.y};
                    if (absAngle > 3*Math.PI/4) return {x: fromNode.x - 50, y: fromNode.y};
                    if (angle > 0) return {x: fromNode.x, y: fromNode.y + 35};
                    return {x: fromNode.x, y: fromNode.y - 35};
                }
                
                return {
                    x: fromNode.x + r * Math.cos(angle),
                    y: fromNode.y + r * Math.sin(angle)
                };
            }
            
            contains(x, y) {
                const start = this.getEdgePoint(this.from, this.to);
                const end = this.getEdgePoint(this.to, this.from);
                return this.pointToLineDistance(x, y, start.x, start.y, end.x, end.y) < 8;
            }
            
            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = lenSq !== 0 ? dot / lenSq : -1;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                return Math.sqrt((px - xx)**2 + (py - yy)**2);
            }
        }
        
        // ==================== ç”»å¸ƒæ“ä½œ ====================
        
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç½‘æ ¼
            ctx.save();
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x < canvas.width; x += 20) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += 20) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
            ctx.restore();
            
            // è¾¹
            currentGraph.edges.forEach(edge => edge.draw());
            
            // èŠ‚ç‚¹
            currentGraph.nodes.forEach(node => node.draw());
            
            // ä¸´æ—¶è¿çº¿
            if (selectedTool === 'edge' && edgeStart) {
                const rect = canvas.getBoundingClientRect();
                const end = {x: lastMousePos.x - rect.left, y: lastMousePos.y - rect.top};
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(edgeStart.x, edgeStart.y);
                ctx.lineTo(end.x, end.y);
                ctx.strokeStyle = '#95a5a6';
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // ==================== äº¤äº’é€»è¾‘ ====================
        
        function setTool(tool) {
            selectedTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const btn = document.getElementById(`btn-${tool}`);
            if (btn) btn.classList.add('active');
            
            const hints = {
                start: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ å¼€å§‹èŠ‚ç‚¹',
                end: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ ç»“æŸèŠ‚ç‚¹',
                process: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ å¤„ç†èŠ‚ç‚¹',
                conditional: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ æ¡ä»¶èŠ‚ç‚¹',
                agent: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ AgentèŠ‚ç‚¹ï¼ˆå¯åŒå‡»è¿›å…¥ç¼–è¾‘ï¼‰',
                tool: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ å·¥å…·è°ƒç”¨èŠ‚ç‚¹',
                human: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ äººå·¥ä¸­æ–­èŠ‚ç‚¹',
                parallel: 'ç‚¹å‡»ç”»å¸ƒæ·»åŠ å¹¶è¡Œç½‘å…³',
                edge: 'ä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªèŠ‚ç‚¹è¿›è¡Œè¿æ¥'
            };
            
            const hint = document.getElementById('hint');
            hint.textContent = hints[tool] || '';
            hint.classList.add('show');
            setTimeout(() => hint.classList.remove('show'), 2000);
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (selectedTool === 'edge') {
                const node = currentGraph.nodes.find(n => n.contains(x, y));
                if (node) {
                    if (!edgeStart) {
                        edgeStart = node;
                    } else if (edgeStart !== node) {
                        const label = (edgeStart.type === 'conditional' || edgeStart.type === 'agent') ? 
                            prompt('è¾“å…¥æ¡ä»¶æ ‡ç­¾ (å¦‚: continue/finish):', 'continue') || '' : '';
                        currentGraph.edges.push(new Edge(edgeStart, node, label));
                        edgeStart = null;
                        draw();
                    }
                }
            } else if (selectedTool && NODE_TYPES[selectedTool]) {
                const node = new Node(x, y, selectedTool, null, 
                    currentPath.length > 1 ? currentPath[currentPath.length - 1] : null);
                currentGraph.nodes.push(node);
                selectedNode = node;
                updateProperties();
                draw();
            } else {
                // é€‰æ‹©æˆ–æ‹–æ‹½
                const node = currentGraph.nodes.find(n => n.contains(x, y));
                if (node) {
                    selectedNode = node;
                    selectedEdge = null;
                    isDragging = true;
                    dragOffset = {x: x - node.x, y: y - node.y};
                    updateProperties();
                    draw();
                } else {
                    const edge = currentGraph.edges.find(e => e.contains(x, y));
                    if (edge) {
                        selectedEdge = edge;
                        selectedNode = null;
                        updateProperties();
                        draw();
                    } else {
                        selectedNode = null;
                        selectedEdge = null;
                        updateProperties();
                        draw();
                    }
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            lastMousePos = {x: e.clientX, y: e.clientY};
            if (isDragging && selectedNode) {
                const rect = canvas.getBoundingClientRect();
                selectedNode.x = e.clientX - rect.left - dragOffset.x;
                selectedNode.y = e.clientY - rect.top - dragOffset.y;
                draw();
            } else if (selectedTool === 'edge' && edgeStart) {
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => { isDragging = false; });
        
        canvas.addEventListener('dblclick', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const node = currentGraph.nodes.find(n => n.contains(x, y));
            if (node && node.type === 'agent' && node.subgraph) {
                enterSubgraph(node);
            } else if (node) {
                const newName = prompt('é‡å‘½åèŠ‚ç‚¹:', node.name);
                if (newName) {
                    node.name = newName;
                    draw();
                    updateProperties();
                }
            }
        });
        
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const edge = currentGraph.edges.find(e => e.contains(x, y));
            if (edge && confirm('åˆ é™¤è¿™æ¡è¿æ¥?')) {
                currentGraph.edges = currentGraph.edges.filter(e => e !== edge);
                selectedEdge = null;
                draw();
                updateProperties();
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedNode) {
                    if (confirm('åˆ é™¤è¿™ä¸ªèŠ‚ç‚¹åŠå…¶è¿æ¥?')) {
                        currentGraph.edges = currentGraph.edges.filter(
                            e => e.from !== selectedNode && e.to !== selectedNode
                        );
                        currentGraph.nodes = currentGraph.nodes.filter(n => n !== selectedNode);
                        selectedNode = null;
                        draw();
                        updateProperties();
                    }
                } else if (selectedEdge) {
                    currentGraph.edges = currentGraph.edges.filter(e => e !== selectedEdge);
                    selectedEdge = null;
                    draw();
                    updateProperties();
                }
            }
        });
        
        // ==================== å­å›¾å¯¼èˆª ====================
        
        function enterSubgraph(agentNode) {
            currentPath.push(agentNode.id);
            currentGraph = agentNode.subgraph;
            updateBreadcrumb();
            selectedNode = null;
            selectedEdge = null;
            document.getElementById('subgraph-hint').classList.add('show');
            draw();
            updateProperties();
        }
        
        function navigateTo(index) {
            if (index === 0) {
                currentPath = ['root'];
                currentGraph = workflowData.root;
            } else {
                // é‡å»ºè·¯å¾„
                const newPath = currentPath.slice(0, index + 1);
                let graph = workflowData.root;
                for (let i = 1; i < newPath.length; i++) {
                    const nodeId = newPath[i];
                    const node = graph.nodes.find(n => n.id === nodeId);
                    if (node && node.subgraph) {
                        graph = node.subgraph;
                    }
                }
                currentPath = newPath;
                currentGraph = graph;
            }
            updateBreadcrumb();
            document.getElementById('subgraph-hint').classList.toggle('show', currentPath.length > 1);
            draw();
            updateProperties();
        }
        
        function navigateToRoot() { navigateTo(0); }
        
        function updateBreadcrumb() {
            const container = document.getElementById('breadcrumb');
            container.innerHTML = '';
            
            currentPath.forEach((id, index) => {
                const span = document.createElement('span');
                span.className = 'breadcrumb-item' + (index === currentPath.length - 1 ? ' active' : '');
                span.textContent = index === 0 ? 'ä¸»å·¥ä½œæµ' : 
                    (workflowData.root.nodes.find(n => n.id === id)?.name || id);
                span.onclick = () => navigateTo(index);
                container.appendChild(span);
                
                if (index < currentPath.length - 1) {
                    const sep = document.createElement('span');
                    sep.className = 'breadcrumb-separator';
                    sep.textContent = 'â€º';
                    container.appendChild(sep);
                }
            });
        }
        
        // ==================== å±æ€§é¢æ¿ ====================
        
        function updateProperties() {
            const panel = document.getElementById('prop-content');
            
            if (selectedNode) {
                const type = NODE_TYPES[selectedNode.type];
                let configHtml = '';
                
                // æ ¹æ®ç±»å‹æ˜¾ç¤ºé…ç½®
                if (selectedNode.type === 'agent') {
                    configHtml = `
                        <div class="prop-group">
                            <label>æ¨¡å‹</label>
                            <input type="text" id="config-model" value="${selectedNode.config.model}" 
                                   onchange="updateNodeConfig('model', this.value)">
                        </div>
                        <div class="prop-group">
                            <label>æœ€å¤§è¿­ä»£æ¬¡æ•°</label>
                            <input type="number" id="config-iter" value="${selectedNode.config.max_iterations}" 
                                   onchange="updateNodeConfig('max_iterations', parseInt(this.value))">
                        </div>
                        <div class="prop-group">
                            <label>ç³»ç»Ÿæç¤ºè¯</label>
                            <textarea id="config-prompt" onchange="updateNodeConfig('system_prompt', this.value)"
                                    >${selectedNode.config.system_prompt}</textarea>
                        </div>
                        <div class="prop-group">
                            <label>å·¥å…·åˆ—è¡¨ (é€—å·åˆ†éš”)</label>
                            <input type="text" id="config-tools" value="${selectedNode.config.tools.join(',')}" 
                                   onchange="updateNodeConfig('tools', this.value.split(',').filter(s=>s))">
                        </div>
                        <div class="prop-group" style="background: #e8daef; padding: 10px; border-radius: 4px;">
                            <strong>ğŸ’¡ æç¤ºï¼š</strong>åŒå‡»æ­¤èŠ‚ç‚¹è¿›å…¥å­å›¾ç¼–è¾‘ï¼Œå®šä¹‰Agentå†…éƒ¨å¾ªç¯é€»è¾‘
                        </div>
                    `;
                } else if (selectedNode.type === 'tool') {
                    configHtml = `
                        <div class="prop-group">
                            <label>å·¥å…·åç§°</label>
                            <input type="text" id="config-tool" value="${selectedNode.config.tool_name}" 
                                   placeholder="å¦‚: web_search" onchange="updateNodeConfig('tool_name', this.value)">
                        </div>
                        <div class="prop-group">
                            <label>è¶…æ—¶æ—¶é—´(ç§’)</label>
                            <input type="number" id="config-timeout" value="${selectedNode.config.timeout}" 
                                   onchange="updateNodeConfig('timeout', parseInt(this.value))">
                        </div>
                        <div class="prop-group">
                            <label>é‡è¯•æ¬¡æ•°</label>
                            <input type="number" id="config-retry" value="${selectedNode.config.retry}" 
                                   onchange="updateNodeConfig('retry', parseInt(this.value))">
                        </div>
                    `;
                } else if (selectedNode.type === 'human') {
                    configHtml = `
                        <div class="prop-group">
                            <label>è¯¢é—®æç¤ºè¯</label>
                            <textarea id="config-prompt" onchange="updateNodeConfig('prompt', this.value)"
                                    >${selectedNode.config.prompt}</textarea>
                        </div>
                        <div class="prop-group">
                            <label>é€‰é¡¹ (é€—å·åˆ†éš”ï¼Œç•™ç©ºä¸ºå¼€æ”¾å¼)</label>
                            <input type="text" id="config-options" value="${selectedNode.config.options.join(',')}" 
                                   onchange="updateNodeConfig('options', this.value.split(',').filter(s=>s))">
                        </div>
                    `;
                } else if (selectedNode.type === 'parallel') {
                    configHtml = `
                        <div class="prop-group">
                            <label>åˆ†æ”¯æ•°é‡</label>
                            <input type="number" id="config-branches" value="${selectedNode.config.branches}" 
                                   min="2" max="10" onchange="updateNodeConfig('branches', parseInt(this.value))">
                        </div>
                        <div class="prop-group">
                            <label>ç­‰å¾…æ¨¡å¼</label>
                            <select id="config-mode" onchange="updateNodeConfig('mode', this.value)">
                                <option value="all" ${selectedNode.config.mode === 'all' ? 'selected' : ''}>ç­‰å¾…å…¨éƒ¨å®Œæˆ (AND)</option>
                                <option value="any" ${selectedNode.config.mode === 'any' ? 'selected' : ''}>ä»»ä¸€å®Œæˆå³å¯ (OR)</option>
                            </select>
                        </div>
                    `;
                }
                
                panel.innerHTML = `
                    <div class="prop-group">
                        <label>èŠ‚ç‚¹ ID</label>
                        <input type="text" value="${selectedNode.id}" disabled>
                    </div>
                    <div class="prop-group">
                        <label>åç§°</label>
                        <input type="text" value="${selectedNode.name}" onchange="updateNodeName(this.value)">
                    </div>
                    <div class="prop-group">
                        <label>ç±»å‹</label>
                        <input type="text" value="${type.label}" disabled>
                    </div>
                    ${configHtml}
                    <div class="prop-group">
                        <button class="tool-btn danger-btn" onclick="deleteSelectedNode()" style="width: 100%;">
                            åˆ é™¤èŠ‚ç‚¹
                        </button>
                    </div>
                `;
            } else if (selectedEdge) {
                panel.innerHTML = `
                    <div class="prop-group">
                        <label>èµ·ç‚¹</label>
                        <input type="text" value="${selectedEdge.from.name}" disabled>
                    </div>
                    <div class="prop-group">
                        <label>ç»ˆç‚¹</label>
                        <input type="text" value="${selectedEdge.to.name}" disabled>
                    </div>
                    <div class="prop-group">
                        <label>æ¡ä»¶æ ‡ç­¾</label>
                        <input type="text" value="${selectedEdge.label}" 
                               onchange="updateEdgeLabel(this.value)">
                    </div>
                    <div class="prop-group">
                        <button class="tool-btn danger-btn" onclick="deleteSelectedEdge()" style="width: 100%;">
                            åˆ é™¤è¿æ¥
                        </button>
                    </div>
                `;
            } else {
                panel.innerHTML = `
                    <p style="color: #999; margin-bottom: 20px;">è¯·é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹æˆ–è¾¹è¿›è¡Œç¼–è¾‘</p>
                    <div class="help-panel">
                        <h4>èŠ‚ç‚¹ç±»å‹è¯´æ˜</h4>
                        <div class="node-legend">
                            <div class="legend-shape" style="background: #9b59b6; border-radius: 4px;"></div>
                            <span><strong>Agentï¼š</strong>åŒ…å«å­å›¾çš„æ™ºèƒ½ä½“ï¼Œæ”¯æŒReActå¾ªç¯</span>
                        </div>
                        <div class="node-legend">
                            <div class="legend-shape" style="background: #e67e22; border-radius: 50% 50% 0 0/20% 20% 0 0; border: 2px solid #e67e22;"></div>
                            <span><strong>Toolï¼š</strong>å¤–éƒ¨å·¥å…·è°ƒç”¨ï¼ˆå¯é…ç½®è¶…æ—¶/é‡è¯•ï¼‰</span>
                        </div>
                        <div class="node-legend">
                            <div class="legend-shape" style="background: #1abc9c; clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);"></div>
                            <span><strong>Humanï¼š</strong>äººå·¥ä»‹å…¥ç‚¹ï¼ˆä¸­æ–­ç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼‰</span>
                        </div>
                        <div class="node-legend">
                            <div class="legend-shape" style="background: #34495e;"></div>
                            <span><strong>Parallelï¼š</strong>å¹¶è¡Œæ‰§è¡Œå¤šä¸ªåˆ†æ”¯</span>
                        </div>
                    </div>
                `;
            }
        }
        
        function updateNodeName(val) { if (selectedNode) { selectedNode.name = val; draw(); } }
        function updateNodeConfig(key, val) { if (selectedNode) { selectedNode.config[key] = val; } }
        function updateEdgeLabel(val) { if (selectedEdge) { selectedEdge.label = val; draw(); } }
        function deleteSelectedNode() {
            if (selectedNode) {
                currentGraph.edges = currentGraph.edges.filter(e => e.from !== selectedNode && e.to !== selectedNode);
                currentGraph.nodes = currentGraph.nodes.filter(n => n !== selectedNode);
                selectedNode = null;
                draw();
                updateProperties();
            }
        }
        function deleteSelectedEdge() {
            if (selectedEdge) {
                currentGraph.edges = currentGraph.edges.filter(e => e !== selectedEdge);
                selectedEdge = null;
                draw();
                updateProperties();
            }
        }
        
        function clearCanvas() {
            if (confirm('ç¡®å®šæ¸…ç©ºå½“å‰ç”»å¸ƒçš„æ‰€æœ‰å†…å®¹?')) {
                currentGraph.nodes = [];
                currentGraph.edges = [];
                currentGraph.idCounter = 0;
                selectedNode = null;
                selectedEdge = null;
                draw();
                updateProperties();
            }
        }
        
        // ==================== ä»£ç ç”Ÿæˆ ====================
        
        function generateCode() {
            const pythonCode = generateGraphCode(workflowData.root, 'main');
            
            // æ”¶é›†æ‰€æœ‰skills
            const skills = [];
            function collectSkills(graph) {
                graph.nodes.forEach(node => {
                    if (node.type === 'agent' && node.config.system_prompt) {
                        skills.push({
                            name: `${node.name}_skill.md`,
                            content: `# ${node.name} Skill

## è§’è‰²
${node.config.system_prompt || 'ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹'}

## å¯ç”¨å·¥å…·
${node.config.tools.join(', ') || 'æ— '}

## ä»»åŠ¡
æ ¹æ®è¾“å…¥çŠ¶æ€è¿›è¡Œå¤„ç†ï¼Œè¿”å›åŠ¨ä½œå†³å®šã€‚

## è¾“å‡ºæ ¼å¼
\`\`\`json
{
  "thought": "æ€è€ƒè¿‡ç¨‹",
  "action": "å·¥å…·åæˆ–finish",
  "input": "å·¥å…·è¾“å…¥"
}
\`\`\``
                        });
                    }
                    if (node.subgraph) collectSkills(node.subgraph);
                });
            }
            collectSkills(workflowData.root);
            
            // æ˜¾ç¤º
            document.getElementById('python-code').textContent = pythonCode;
            
            const skillsDiv = document.getElementById('skills-content');
            skillsDiv.innerHTML = skills.map(s => `
                <div class="code-block">
                    <h4>${s.name}</h4>
                    <pre>${s.content}</pre>
                </div>
            `).join('');
            
            document.getElementById('graph-json').textContent = JSON.stringify(workflowData, null, 2);
            document.getElementById('code-modal').classList.add('show');
        }
        
        function generateGraphCode(graph, name, isSubgraph = false) {
            let code = isSubgraph ? '' : `import asyncio
from typing import Literal, Optional, Dict, Any, List
from langgraph.graph import StateGraph, END
from dataclasses import dataclass, field

@dataclass
class State:
    messages: List[Dict] = field(default_factory=list)
    next: Optional[str] = None
`;
            
            // ç”Ÿæˆå­å›¾ç¼–è¯‘å‡½æ•°
            code += `
def build_${name}_graph():
    workflow = StateGraph(State)
`;
            
            // æ·»åŠ èŠ‚ç‚¹
            graph.nodes.forEach(node => {
                if (node.type === 'start' || node.type === 'end') return;
                
                if (node.type === 'agent') {
                    code += `
    # AgentèŠ‚ç‚¹: ${node.name} (åŒ…å«å­å›¾)
    def ${node.name}_node(state):
        # è¿›å…¥Agentå­å›¾æ‰§è¡Œ
        subapp = build_${node.name}_subgraph()
        result = subapp.invoke(state)
        return result
    
    workflow.add_node("${node.name}", ${node.name}_node)
`;
                    // é€’å½’ç”Ÿæˆå­å›¾ä»£ç ï¼ˆæ”¾åœ¨åé¢ï¼‰
                } else if (node.type === 'tool') {
                    code += `
    # å·¥å…·èŠ‚ç‚¹: ${node.name}
    def ${node.name}_node(state):
        print(f"ğŸ”§ æ‰§è¡Œå·¥å…·: ${node.config.tool_name || node.name}")
        # TODO: å®ç° ${node.config.tool_name || 'å·¥å…·'}
        return {"messages": [{"role": "tool", "content": "result"}]}
    
    workflow.add_node("${node.name}", ${node.name}_node)
`;
                } else if (node.type === 'human') {
                    code += `
    # äººå·¥ä¸­æ–­èŠ‚ç‚¹: ${node.name}
    def ${node.name}_node(state):
        print(f"ğŸ‘¤ ç­‰å¾…äººå·¥è¾“å…¥: ${node.config.prompt || ''}")
        # å®é™…åº”ä½¿ç”¨ interrupt æœºåˆ¶
        return {"messages": [{"role": "human", "content": "user_input"}]}
    
    workflow.add_node("${node.name}", ${node.name}_node)
`;
                } else if (node.type === 'parallel') {
                    code += `
    # å¹¶è¡Œç½‘å…³: ${node.name}
    def ${node.name}_node(state):
        # ${node.config.mode === 'all' ? 'ç­‰å¾…å…¨éƒ¨å®Œæˆ' : 'ä»»ä¸€å®Œæˆå³å¯'}
        return state
    
    workflow.add_node("${node.name}", ${node.name}_node)
`;
                } else {
                    code += `
    # å¤„ç†èŠ‚ç‚¹: ${node.name}
    def ${node.name}_node(state):
        print(f"â–¶ï¸ æ‰§è¡Œ: ${node.name}")
        return {"messages": [{"role": "assistant", "content": "processed"}]}
    
    workflow.add_node("${node.name}", ${node.name}_node)
`;
                }
            });
            
            // æ·»åŠ è¾¹
            graph.edges.forEach(edge => {
                if (edge.from.type === 'conditional' || edge.from.type === 'agent') {
                    // æ¡ä»¶è¾¹åœ¨routerä¸­å¤„ç†ï¼Œè¿™é‡Œåªæ·»åŠ æ™®é€šè¾¹
                    code += `    # æ¡ä»¶åˆ†æ”¯: ${edge.label}\n`;
                } else {
                    code += `    workflow.add_edge("${edge.from.name}", "${edge.to.name}")
`;
                }
            });
            
            // æ·»åŠ æ¡ä»¶è·¯ç”±
            const conditionalNodes = graph.nodes.filter(n => n.type === 'conditional' || n.type === 'agent');
            conditionalNodes.forEach(node => {
                const outEdges = graph.edges.filter(e => e.from === node);
                if (outEdges.length > 0) {
                    code += `
    def ${node.name}_router(state) -> Literal[${outEdges.map(e => `"${e.to.name}"`).join(', ')}]:
        # æ ¹æ®çŠ¶æ€å†³å®šè·¯ç”±
        return "${outEdges[0].to.name}"  # TODO: å®ç°è·¯ç”±é€»è¾‘
    
    workflow.add_conditional_edges(
        "${node.name}",
        ${node.name}_router,
        {${outEdges.map(e => `"${e.to.name}": "${e.to.name}"`).join(', ')}}
    )
`;
                }
            });
            
            // è®¾ç½®å…¥å£
            const startNode = graph.nodes.find(n => n.type === 'start');
            if (startNode) {
                const firstEdge = graph.edges.find(e => e.from === startNode);
                if (firstEdge) {
                    code += `    workflow.set_entry_point("${firstEdge.to.name}")
`;
                }
            }
            
            code += `    return workflow.compile()
`;
            
            // é€’å½’ç”ŸæˆAgentå­å›¾
            graph.nodes.forEach(node => {
                if (node.type === 'agent' && node.subgraph) {
                    code += `
# ${node.name} çš„å­å›¾å®šä¹‰
${generateGraphCode(node.subgraph, node.name + '_subgraph', true)}
`;
                }
            });
            
            if (!isSubgraph) {
                code += `
if __name__ == "__main__":
    app = build_${name}_graph()
    result = app.invoke({"messages": []})
    print(result)
`;
            }
            
            return code;
        }
        
        // ==================== å¯¼å…¥å¯¼å‡º ====================
        
        function exportGraph() {
            const dataStr = JSON.stringify(workflowData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `agent_workflow_${Date.now()}.json`;
            a.click();
        }
        
        function importGraph(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // é€’å½’é‡å»ºèŠ‚ç‚¹å’Œè¾¹
                    function rebuildGraph(g) {
                        const newGraph = {nodes: [], edges: [], idCounter: g.idCounter || 0};
                        const nodeMap = {};
                        
                        g.nodes.forEach(n => {
                            const node = new Node(n.x, n.y, n.type, n.name, n.parentId);
                            node.id = n.id;
                            node.config = n.config || {};
                            if (n.subgraph) {
                                node.subgraph = rebuildGraph(n.subgraph);
                            }
                            newGraph.nodes.push(node);
                            nodeMap[n.id] = node;
                        });
                        
                        g.edges.forEach(e => {
                            const from = nodeMap[e.from];
                            const to = nodeMap[e.to];
                            if (from && to) {
                                newGraph.edges.push(new Edge(from, to, e.label));
                            }
                        });
                        
                        return newGraph;
                    }
                    
                    workflowData = {root: rebuildGraph(data.root)};
                    currentPath = ['root'];
                    currentGraph = workflowData.root;
                    updateBreadcrumb();
                    draw();
                    alert('å¯¼å…¥æˆåŠŸï¼');
                } catch (err) {
                    alert('å¯¼å…¥å¤±è´¥: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(`tab-${tab}`).classList.add('active');
        }
        
        function closeModal() {
            document.getElementById('code-modal').classList.remove('show');
        }
        
        function downloadFile(filename, type) {
            const content = type === 'python' ? 
                document.getElementById('python-code').textContent :
                document.getElementById('graph-json').textContent;
            const blob = new Blob([content], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
        }
        
        function copyToClipboard(type) {
            const text = document.getElementById('python-code').textContent;
            navigator.clipboard.writeText(text).then(() => alert('å·²å¤åˆ¶ï¼'));
        }
        
        // åˆå§‹åŒ–
        updateBreadcrumb();
        draw();
    </script>
</body>
</html>